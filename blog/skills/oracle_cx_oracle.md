
```sql
-- drop the existing table
-- DROP TABLE students;

CREATE TABLE students (
	id NUMBER GENERATED by default on null as IDENTITY,
	st_name varchar(250) NOT NULL,
	dob timestamp NOT NULL,
	studentid NUMBER NOT NULL,
	PRIMARY KEY (id),
	UNIQUE (st_name, dob),
	UNIQUE (studentid)
);
```

## Connect to database with Connection and Cursor objects
The required parameters for connecting to an Oracle database are
* database username (example: system)
* database password (example: p#ssw0rd)
* database server host (example: localhost / 192.168.19.5)
* database server listening port (example: 1521)
* database service name (example: xepdb1 or ORCL)

All the above parameters will be used to create a connection string in the format ```<username>/<password>@<dbHostAddress>:<dbPort>/<dbServiceName>``` (example: system/p#ssw0rd@localhost:1521/xepdb1)

```python
import cx_Oracle

# connection string in the format
# <username>/<password>@<dbHostAddress>:<dbPort>/<dbServiceName>
connStr = 'system/pass@localhost:1521/xepdb1'

# initialize the connection object
conn = None
try:
    # create a connection object
    conn = cx_Oracle.connect(connStr)

    # get a cursor object from the connection
    cur = conn.cursor()

    # do something with the database
except Exception as err:
    print('Error while connecting to the db')
    print(err)
finally:
    if(conn):
        # close the cursor object to avoid memory leaks
        cur.close()

        # close the connection object also
        conn.close()
print("execution complete!")
```

-   The above python program uses a connection object and a cursor object.
-   **Connection object** establishes connection with the database.
-   **Cursor object** uses the connection object to execute SQL commands in the database to update data or fetch data from the database.
-   Cursors can also perform transactions for atomic execution of multiple commands. That means either all SQL commands will be executed, or else all the SQL commands will be cancelled.

## Fetch rows from database
```python
import cx_Oracle
import datetime as dt
import pandas as pd

# connection string in the format
# <username>/<password>@<dbHostAddress>:<dbPort>/<dbServiceName>
connStr = 'system/pass@localhost:1521/xepdb1'

# initialize the connection object
conn = None
try:
    # create a connection object
    conn = cx_Oracle.connect(connStr)

    # get a cursor object from the connection
    cur = conn.cursor()

    # create sql for querying data
    sqlTxt = 'select st_name, dob, studentid from "test1".STUDENTS \
                where dob >= :1 and studentid > :2 \
                order by st_name, studentid'
    # execute the sql to perform data extraction
    cur.execute(sqlTxt, (dt.datetime(2018, 1, 1, 0, 0, 0), 3000))

    rowCount = cur.rowcount
    print("number of fetched rows =", rowCount)

    # get the column names returned from the query
    colNames = [row[0] for row in cur.description]

    # fetch all rows from query
    dbRows = cur.fetchall()

    # iterate through all the fetched rows
    for rowIter in range(len(dbRows)):
        print("reading data from {0} row".format(rowIter))
        rowTuple = dbRows[rowIter]
        print("name =", rowTuple[0])
        print("dob =", rowTuple[1])
        print("studentId =", rowTuple[2])

    # create a dataframe from the fetched records (optional)
    recordsDf = pd.DataFrame.from_records(dbRows, columns=colNames)
except Exception as err:
    print('Error while fetching rows from db')
    print(err)
finally:
    if(conn):
        # close the cursor object to avoid memory leaks
        cur.close()

        # close the connection object also
        conn.close()
print("data fetch example execution complete!")
```

* In the above code we have created an SQL fetch command to be executed as a string.

```python
sqlStr = "select name, dob, studentid from public.students \
where dob >= %s and studentid > %s \
order by name, studentid"
```

* We have also given SQL input placeholders as ```%s``` to inject python variables into SQL statement while execution. This is a strongly recommended way of inserting variables in SQL commands since this avoids SQL injection attacks in our python programs.
* ```cur.fetchall()``` will return the results of SQL fetch query as a list of tuples from our cursor variable.
* ```[row[0] for row in cur.description]``` will return the column names in order for the fetched list of data tuples. 
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIxMzgxMzI1NjUsLTE4NTc5MTE5MDUsLT
ExOTgzNjQ1MzUsLTIwODg3NDY2MTJdfQ==
-->